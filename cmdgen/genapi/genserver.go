package genapi

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/soryetong/gooze-starter/gzconsole"
	"github.com/soryetong/gooze-starter/pkg/gzutil"
)

const serverContentTemplate = `
// Code generated by gooze-starter. DO NOT EDIT.
// This file was generated at: {{.NowTime}}
package {{.PackageName}}

import (
	"github.com/soryetong/gooze-starter/gooze"
	"github.com/soryetong/gooze-starter/pkg/gzutil"
	"github.com/soryetong/gooze-starter/modules/httpmodule"
	"{{ .RouterPackagePath}}"
	"{{ .HandlerPackagePath}}"
)

func init() {
	gooze.RegisterService(&{{ .ServerName}}{})
}

type {{ .ServerName}} struct {
	*gooze.IServer

	httpModule httpmodule.IHttp
}

func RegisterCustomHandlers() {
{{- range .Hooks}}
	handler.Set{{ .UcName }}CustomHandler(handler.New{{.UcName}}CustomHandlerImp())
{{- end}}
}

func (self *{{ .ServerName}}) OnStart() (err error) {
	RegisterCustomHandlers()
	// 添加回调函数
	self.httpModule.OnStop(self.exitCallback())

	{{if .HasViper}} self.httpModule.Init(self, viper.GetString("App.Addr"), 5, router.InitRouter()) {{ else }}
	self.httpModule.Init(self, {{ .ServerAddr}}, {{ .Timeout}}, router.InitRouter()) {{end}}
	err = self.httpModule.Start()

	return
}

// TODO 添加回调函数, 无逻辑可直接删除这个方法
func (self *{{ .ServerName}}) exitCallback() *gzutil.OrderlyMap {
	callback := gzutil.NewOrderlyMap()
	callback.Append("exit", func() {
		gooze.Log.Info("这是程序退出后的回调函数, 执行你想要执行的逻辑, 无逻辑可以直接删除这段代码")
	})
	
	return callback
}
`

type hookNameList struct {
	UcName string
}

// 提取旧的 RegisterCustomHandlers 方法里的 hooks
func extractOldHooks(src []byte) map[string]bool {
	// 这里用两个捕获组 (SetXxx, NewXxx)，手动判断一致性
	re := regexp.MustCompile(`handler\.Set(\w+)CustomHandler\(handler\.New(\w+)CustomHandlerImp\(\)\)`)
	matches := re.FindAllStringSubmatch(string(src), -1)
	old := make(map[string]bool)
	for _, m := range matches {
		if len(m) > 2 && m[1] == m[2] {
			old[m[1]] = true
		}
	}
	return old
}

// 生成新的 RegisterCustomHandlers 方法（合并新旧 hooks，去重+排序）
func (self *generator) genRegisterCustomHandlers(src []byte, hooks []hookNameList) string {
	oldHooks := extractOldHooks(src)

	// 合并新旧 hooks
	hookSet := make(map[string]bool)
	for name := range oldHooks {
		hookSet[name] = true
	}
	for _, h := range hooks {
		hookSet[h.UcName] = true
	}

	// 排序（保证输出稳定）
	names := make([]string, 0, len(hookSet))
	for name := range hookSet {
		names = append(names, name)
	}
	sort.Strings(names)

	// 拼接方法体
	var b strings.Builder
	b.WriteString("func RegisterCustomHandlers() {\n")
	for _, name := range names {
		b.WriteString(fmt.Sprintf("\thandler.Set%sCustomHandler(handler.New%sCustomHandlerImp())\n", name, name))
	}
	b.WriteString("}\n")
	return b.String()
}

func (self *generator) GenServer() (err error) {
	outputName := gzutil.Ternary(self.moduleName == "", "http", self.moduleName)
	serverName := fmt.Sprintf("%sServer", gzutil.UcFirst(outputName))
	path := filepath.Join(self.output, self.moduleName, self.serverPackageName)

	if err = os.MkdirAll(path, os.ModePerm); err != nil {
		return err
	}

	var hookNameListData []hookNameList
	for _, name := range self.hookList {
		hookNameListData = append(hookNameListData, hookNameList{
			UcName: gzutil.UcFirst(name),
		})
	}

	filename := filepath.Join(path, fmt.Sprintf("%s.go", serverName))

	// 文件已存在 -> 更新 RegisterCustomHandlers
	if _, err = os.Stat(filename); err == nil {
		src, err := os.ReadFile(filename)
		if err != nil {
			return err
		}

		newHandlerFunc := self.genRegisterCustomHandlers(src, hookNameListData)

		// 正则匹配 RegisterCustomHandlers 方法
		re := regexp.MustCompile(`func RegisterCustomHandlers\(\) \{[\s\S]*?\}`)
		var updated []byte
		if re.Match(src) {
			// 替换
			updated = re.ReplaceAll(src, []byte(newHandlerFunc))
			gzconsole.Echo.Info(fmt.Sprintf("更新 RegisterCustomHandlers 方法: %s", filename))
		} else {
			// 如果原文件没有 RegisterCustomHandlers 方法，就在文件末尾追加
			updated = append(src, []byte("\n\n"+newHandlerFunc)...)
			gzconsole.Echo.Info(fmt.Sprintf("追加 RegisterCustomHandlers 方法: %s", filename))
		}

		err = os.WriteFile(filename, updated, 0644)
		if err != nil {
			return err
		}
		self.formatFileWithGofmt(filename)
		return nil
	}

	// 文件不存在 -> 走原始逻辑，创建文件
	contentTmpl, err := template.New("server").Parse(serverContentTemplate)
	if err != nil {
		return err
	}

	var builder strings.Builder
	data := map[string]interface{}{
		"PackageName":        self.serverPackageName,
		"ServerName":         serverName,
		"ServerAddr":         "gooze.Config.App.Addr",
		"HasViper":           false,
		"Timeout":            "gooze.Config.App.Timeout",
		"RouterPackagePath":  filepath.Join(self.packageName, self.routerPackagePath),
		"Hooks":              hookNameListData,
		"HandlerPackagePath": filepath.Join(self.packageName, self.handlerPackagePath),
		"NowTime":            time.Now().Format("2006-01-02 15:04:05"),
	}
	if err = contentTmpl.Execute(&builder, data); err != nil {
		return err
	}
	builder.WriteString("")

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	gzconsole.Echo.Info("正在生成服务文件: ", filename)
	if _, err = file.WriteString(builder.String()); err != nil {
		return err
	}
	self.formatFileWithGofmt(filename)

	return nil
}
