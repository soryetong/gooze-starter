package genapi

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"time"

	"golang.org/x/tools/imports"
)

func matchType(content string) ([]*dtoContentsSpec, error) {
	var results []*dtoContentsSpec

	lines := strings.Split(content, "\n")
	var buf []string
	var structName string
	inStruct := false

	for _, line := range lines {
		lineTrim := strings.TrimSpace(line)
		if strings.HasPrefix(lineTrim, "type ") && strings.HasSuffix(lineTrim, "{") {
			parts := strings.Fields(lineTrim)
			if len(parts) < 2 {
				continue
			}
			structName = parts[1]
			inStruct = true
			buf = append(buf, fmt.Sprintf("type %s struct {", structName))
			continue
		}
		if inStruct {
			buf = append(buf, line)
			if lineTrim == "}" {
				src := "package p\n\n" + strings.Join(buf, "\n")
				spec, err := parseStruct(structName, src)
				if err != nil {
					return nil, err
				}
				results = append(results, spec)
				// reset
				inStruct = false
				buf = nil
				structName = ""
			}
		}
	}
	return results, nil
}

func parseStruct(name, src string) (*dtoContentsSpec, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "src.go", src, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parse error: %w\n--- source ---\n%s\n--- end ---", err, src)
	}

	var result = &dtoContentsSpec{Name: name}
	// 遍历 AST
	for _, decl := range file.Decls {
		gd, ok := decl.(*ast.GenDecl)
		if !ok || gd.Tok != token.TYPE {
			continue
		}
		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				continue
			}
			for _, field := range st.Fields.List {
				// 可能有多个字段名（如 A,B int）
				for _, nameIdent := range field.Names {
					var buf bytes.Buffer
					_ = printer.Fprint(&buf, fset, field.Type)
					typ := buf.String()

					tag := ""
					if field.Tag != nil {
						tag = strings.Trim(field.Tag.Value, "`")
					}
					comment := ""
					if field.Comment != nil {
						comment = strings.TrimSpace(field.Comment.Text())
					}

					result.Fields = append(result.Fields, &dtoFieldSpec{
						Name:    nameIdent.Name,
						Type:    typ,
						Tag:     tag,
						Comment: comment,
					})
				}
			}
		}
	}
	return result, nil
}

func (self *generator) MatchDto(content string) (err error) {
	specs, err := matchType(content)
	if err != nil {
		return err
	}

	self.dtoContents = specs
	return nil
}

func (self *generator) GenDto() (err error) {
	filename := filepath.Join(self.output, self.moduleName, self.dtoPackageName, self.fileName)
	if err = os.MkdirAll(filepath.Dir(filename), os.ModePerm); err != nil {
		return err
	}

	structs, err := generateStructs(self.dtoPackageName, self.dtoContents)
	if err != nil {
		return err
	}

	return os.WriteFile(filename, []byte(structs), 0644)
}

// generateStructs converts []*dtoContentsSpec into Go source code
func generateStructs(pkgName string, specs []*dtoContentsSpec) (string, error) {
	var buf bytes.Buffer
	now := time.Now().Format(time.DateTime)
	buf.WriteString("// Code generated by gooze-starter. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// This file was generated at: %s\n\n", now))
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	for _, s := range specs {
		buf.WriteString(fmt.Sprintf("type %s struct {\n", s.Name))
		for _, f := range s.Fields {
			tag := ""
			if f.Tag != "" {
				tag = fmt.Sprintf(" `%s`", f.Tag)
			}
			comment := ""
			if f.Comment != "" {
				comment = " // " + f.Comment
			}
			buf.WriteString(fmt.Sprintf("\t%s %s%s%s\n", f.Name, f.Type, tag, comment))
		}
		buf.WriteString("}\n\n")
	}

	formatted, err := imports.Process("", buf.Bytes(), &imports.Options{
		Comments:   true,
		TabIndent:  true,
		TabWidth:   8,
		FormatOnly: false,
	})
	if err != nil {
		return "", fmt.Errorf("goimports failed: %w\n--- code ---\n%s", err, buf.String())
	}

	formatted, err = format.Source(formatted)
	if err != nil {
		return "", fmt.Errorf("format failed: %w\n--- code ---\n%s", err, string(formatted))
	}

	return string(formatted), nil
}
